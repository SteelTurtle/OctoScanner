<#DISCLAIMER

  OCTOSCANNER PowerShell Module version 2.0.2 - last code revision: 14/10/2015. Requires at least PowerShell v.3 to work.
  Author: Daniele Mancuso (daniele.mancuso@avanade.com)
  Using public domain code for the (excellent!) MultiThreading engine section written by Ryan Witschger @(http://www.Get-Blog.com), and
  for the CSV Exporter (Convert-OutputForCSV) by Boe Prox
  This PowerShell Module is freely distributable and available to anyone.
  ...Just spend some good words on the author if you like it!       
#>

######################################################################################

#Global variables - default values of the for the various Function parameters
$LogFileLocationDefault = "%userprofile%\desktop"
$sampleIntervalDefault = 2
$maxSamplesDefault = 2

# Modify the default Connection String and SELECT statements that will be used to query the SQL Server DB
# with the Get-DataFromSQLServer cmdlet. Please update all the parameters according to your environment.
$SQLConnectionStringDefault = "Server = SQLSERVER\SQLINSTANCE; Database =SystemInfoTEST; Trusted_Connection = True"
$SqueryStatementDefault = "SELECT [computername] FROM [SystemInfoTestDB].[dbo].[SysInfo2]"

<#Below You'll find the default syntax of an UPDATE query statement, showing how to update an existing set of "ComputerName" on a DB with all the values
 retrieved from the Data Set generated by the System-Scanner cmdlet. Please use this query format as a template when building your own INSERT/ UPDATE queries

$UQueryStatementDefault = @"
            UPDATE [SystemInfoTestDB].[dbo].[SysInfo2] SET 
            [OSVersion] ='$($objScanner.'OS Version')',
            [AvailableMemory(GB)] ='$($objScanner.'Available Memory (GB)')',
            [AverageDiskReadQueue] ='$($objScanner.'Average Disk Read Queue')',
            [CommittedBytes(%)] ='$($objScanner.'CommittedBytes (%)')',
            [DNSSearchOrder] ='$($objScanner.'DNS Search Order')',
            [LogicalDiskTime(%)] ='$($objScanner.'Logical Disk Time (%)')',
            [LogicalProcessorTotalActivity(%)] ='$($objScanner.'Logical Processor Total Activity (%)')',
            [LogicalProcessorsCores] ='$($objScanner.'Logical Processors Cores')',
            [MachineDomain] ='$($objScanner.'Machine Domain')',
            [ActiveDirectorySite] = '$($objScanner.'Active Directory Site')',
            [MachineManufacturer] ='$($objScanner.'Machine Manufacturer')',
            [MachineModel] ='$($objScanner.'Machine Model')',
            [MemoryPagesPerSecond] ='$($objScanner.'Memory Pages per Second')',
            [MemoryPaging(%)] = '$($objScanner.'Memory Paging (%)')',
            [NetworkInterfaces(Bytes/sec)] ='$($objScanner.'Network Interfaces (Bytes/sec)')',
            [NetworkPacketsReceiveErrors] = '$($objScanner.'Network Packet Received Errors')',
            [NetworkPacketsOutboundErrors] = '$($objScanner.'Network Packet Outbound Errors')',
            [NetworkOutputQueueLength] ='$($objScanner.'Network Output Queue Length')',
            [Organization] ='$($objScanner.'Organization')',
            [OSArchitecture] ='$($objScanner.'OS Architecture')',
            [OSName] ='$($objScanner.'OS Name')',
            [PhysicalDiskAverageRead(ms)] ='$($objScanner.'Physical Disk Average Read (ms)')',
            [PhysicalDiskAverageWrite(ms)] ='$($objScanner.'Physical Disk Average Write (ms)')',
            [PhysicalDiskIdleTime(ms)] ='$($objScanner.'Physical Disk Idle Time (ms)')',
            [ProcessorSockets] ='$($objScanner.'Processor Sockets')',
            [SerialNumber] ='$($objScanner.'Serial Number')',
            [TotalPhysicalMemory(GB)] ='$($objScanner.'Total Physical Memory (GB)')',
            [DataSamplingDate] = '$($objScanner.'Data Sampling Date')',
            [TotalSamplingIntervalInSeconds] ='$($objScanner.'Total Sampling Interval in seconds')'
            
             WHERE ComputerName = '$($objScanner.ComputerName)'
"@
#>


#################################################################################


<#
.Synopsis
   This function query a single computer or a list of computers for a specific subset of system information and performance counters.
   Start-SystemScannerMT works using MultiThreading, so it is better suited for long tasks executed in parallel and on multiple machines. 
   It also accept input from the pipeline. 
   If the scanner is invoked with the switch "UseLocalCulture", the decimal number format separator will be changed from "." to "," (That is how 
   we do it in Mainland Europe, dear friends...)   
.EXAMPLE
   .\Start-SystemScannerMT -Computername localhost -ErrorLog "c:\temp\logfile.txt"

   .\Start-SystemScannerMT -Computername localhost | Format-Table
.EXAMPLE
   'WindowsPC01', 'WidowsPC02', 'WindowsPC03' | Start-SystemScannerMT | Format-Table

   Import-Csv .\computers.csv | Start-SystemScannerMT | Format-Table
#>


function Start-SystemScannerMT
{
    [CmdletBinding()]
    [OutputType([int])]
    Param
    (
        # Default Function Parameters
        [Parameter(Mandatory=$true,
                    HelpMessage="Please specify at least one computer name to be scanned",
                    ValueFromPipelineByPropertyName=$true,
                    ValueFromPipeline=$true)]
                   [string[]]$computerName,
        [int]$SampleInterval = 2,
        [int]$MaxSamples = 2,
        [string]$ErrorLog = $LogFileLocationDefault,
        [switch]$ShowProgressBar,
        [switch]$LogErrors,
        [switch]$UseLocalCulture
        
        
    )

    #BEGIN
    Begin
    {
        #Not defined in version 2.x.x of the Module 
    }
    
    
    #PROCESS
    Process
    {

            
            $oldCulture = [System.Threading.Thread]::CurrentThread.CurrentUICulture
            
            if($UseLocalCulture)
                {
                    
                    [System.Threading.Thread]::CurrentThread.CurrentUICulture.NumberFormat.NumberDecimalSeparator = "."
                    [System.Threading.Thread]::CurrentThread.CurrentUICulture.TextInfo.ListSeparator = ";" 
                    [System.Threading.Thread]::CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator = "."
                    [System.Threading.Thread]::CurrentThread.CurrentUICulture.TextInfo.ListSeparator = ";"
                    
                }
            
            #Main Loop        
            foreach ($computer in $computername) 
            {
                Write-Verbose "Querying Active Directory Domain Services for information about $computer"
                
                <#First of all, let's try connect to the local Active Directory infrastructure 
                  to get several computer's information from there. 
                  NOTICE THAT, in the current version of the scanner, $objADComputer is never used after the initial creation in the script. 
                  Nevertheless, having the $objADComputer properly set means that you could query any scanned computer for some AD-specific properties
                  without any further effort.#>  
                $searcher=New-Object DirectoryServices.DirectorySearcher
                $searcher.Filter="(&(objectCategory=Computer)(Name=$computer))"
                $objADComputer = $searcher.FindOne()

                <# Generate a progress bar indicating the completion status of the analysis if more than one PC is passed to the 
                  PowerShell Function as an argument. The progress bar can be switched off by setting the $ShowProgressBar parameter to "false"
                  Notice that, due to architectural limitation of PowerShell, the progress bar will NOT work if you pass the list of computers
                  you want to scan using the pipeline instead of their direct invocation as cmdlet parameters  #>
                $CompletionPercentage = 0
                $SingleComputerPercentage = (100 / ($computerName.Count) -as [int]) 
                       
                Write-Verbose "Beginning connection to WMI Providers on $computer"
        
                #Update the banner of the Progress Bar
                if($ShowProgressBar)
                {Write-Progress -Activity "Analyzing computer $computer" -CurrentOperation "Hardware and OS Information" -PercentComplete $CompletionPercentage}
                    
                    try
                    {
                         #Set a Status flag; proceed to further operations only if 'true'
                         $StatusOK = $true

                         <# The Script attempts an initial connection to one of the Computer's WMI provider.If this connection fails, 
                            there is no reason to continue any operation for the current machine, as there is probably some network
                            or software problem stopping PowerShell to complete its task #>
                         $objOperatingSystem = Get-WmiObject -ComputerName $computer -Class win32_OperatingSystem -ErrorAction Stop
                    
                    }#End of try
                    
                    catch         
                    {
                        $StatusOK = $false
                        Write-Warning "There was a problem while attempting a connection to $computer. Please verify that this machine`
                        is online and reachable on the network. Also, check that firewall rules and the WinRM Service have been configured correctly.`
                        For more information, type about_Remote_Requirements from the PowerShell prompt"
                        Write-Warning "Data Collection on $computer will be skipped."
                        if ($LogErrors) 
                        {
                            $computer | Out-File $ErrorLog -Append
                            Write-Warning "A Log File has been created in the following directory: '$ErrorLog'"
                        }
                    }#End of catch
                     
                    
                    # If PowerShell has managed to establish a connection with the target machine, the Data collection phase will continue...
                    # Set the $StatusOk switch to "true" and begin the main loop
                    if($StatusOK)
                    {
                        # Update (again) the banner of the Progress Bar 
                        if($ShowProgressBar){Write-Progress -Activity "Analyzing computer $computer" -CurrentOperation "Performance Counters" -PercentComplete $CompletionPercentage}
                                          
                        # Variable containing the starting time of the sampling process
                        $SamplingStart = Get-Date
                        Write-Verbose "Data Collection on $computer started at $SamplingStart"
                        try
                        { 
                            <# Connect to the additional WMI Counters. You can connect to as many counters as you wish. Just consider that this will
                               greatly increase the resources stress on the remote client. Not to mention the increased use of network bandwidth... #>
                            $objComputerSystem = Get-WmiObject  -ComputerName $computer -Class win32_ComputerSystem
                            $objNetworkAdapterConfig = Get-WmiObject -Computername $computer -Class Win32_NetworkAdapterConfiguration -Filter "IPEnabled='True'"

                            #######################################################################################################################
                            # Experimental part, not yet completed or implemented. The purpose would be to get the EXACT performance
                            # counters' names of the remote machines' network adapters connected to the network and responding to the scanner's queries.
                            # Currently, the scanner is not really efficient in getting useful results form multi-homed machines...
                            # See if you can get a solution to the problem! :)
                            ########################################################################################################################
                            
                            <#First, get the IP from wich this computer is answering. The IP address of the network card will then be used to obtain the "Description" field of
                            network card itself. This step is necessary because, when calling the Performance Counters of the nework interface, we must
                            specify the exact card description that is going to be tested #>
                                                  
                            #$connectedIP = (Test-Connection -ComputerName $computer -Count 1 -BufferSize 16).IPV4Address.IPAddressToString
                            #$activeNetAdapterInterfaceIndex = (Get-WmiObject win32_networkadapterconfiguration | Where-Object { ($_.IPAddress -eq $connectedIP) }).InterfaceIndex
                            
                            #still need to correlate the interface index... I'll do it tomorrow

                            #$interfaceindex = Invoke-Command -Computer $computer -AsJob -ScriptBlock {Get-NetAdapter} | Out-Null  
                            #$interfaceinstance = $interfaceindex.InstanceID         
                            
                            #....and then, in theory, this should work... In theory.
                            # $task1 = {(Get-Counter -Counter "\Network Interface(isatap.$interfaceinstance)\Bytes Total/sec" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}                                                    

                            #############################################################################################
                            #############################################################################################


                                                                                         
                            <#Each of the following variables save an instance of a specific performance counter. 
                            Performance Counters can be added here in an unlimited number, but it must be remembered that the Data sampling process in 
                            this script happens in sequential order (Single Threading). The number of seconds necessary to complete the collecting phase can be calculated with the
                            following expression: (number of counters) X (number of samples collected) X (sample intervals)
                            #>
                            
                                                        
                            $task1 = {(Get-Counter -Counter "\IPv4\Datagrams/sec" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples} 
                            $task2 = {(Get-Counter -Counter "\Network Interface(*)\Bytes Total/sec" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task3 = {(Get-Counter -Counter "\Network Interface(*)\Packets Received Errors" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task4 = {(Get-Counter -Counter "\Network Interface(*)\Packets Outbound Errors" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task5 = {(Get-Counter -Counter "\Network Interface(*)\Output Queue Length" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task6 = {(Get-Counter -Counter "\Memory\% Committed Bytes In Use" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task7 = {(Get-Counter -Counter "\memory\available bytes"  -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task8 = {(Get-Counter -Counter "\memory\pages/sec"  -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task9 = {(Get-Counter -Counter "\Paging File(_total)\% Usage" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task10 = {(Get-Counter -Counter "\LogicalDisk(_Total)\% disk time" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task11 = {(Get-Counter -Counter "\physicaldisk(_total)\% idle time" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task12 = {(Get-Counter -Counter "\physicaldisk(_total)\avg. disk sec/read" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task13 = {(Get-Counter -Counter "\physicaldisk(_total)\avg. disk sec/write" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task14 = {(Get-Counter -Counter "\LogicalDisk(_Total)\avg. disk read queue length" -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}
                            $task15 = {(Get-Counter -Counter "\Processor(_total)\% Processor Time"  -SampleInterval $args[0] -MaxSamples $args[1]).CounterSamples}

                            #START MULTITHREADING#
                            #Initializes a Job Pool

                            $job1 = Start-Job -ScriptBlock $task1 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job2 = Start-Job -ScriptBlock $task2 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job3 = Start-Job -ScriptBlock $task3 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job4 = Start-Job -ScriptBlock $task4 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job5 = Start-Job -ScriptBlock $task5 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job6 = Start-Job -ScriptBlock $task6 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job7 = Start-Job -ScriptBlock $task7 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job8 = Start-Job -ScriptBlock $task8 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job9 = Start-Job -ScriptBlock $task9 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job10 = Start-Job -ScriptBlock $task10 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job11 = Start-Job -ScriptBlock $task11 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job12 = Start-Job -ScriptBlock $task12 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job13 = Start-Job -ScriptBlock $task13 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job14 = Start-Job -ScriptBlock $task14 -ArgumentList @("$SampleInterval","$MaxSamples")
                            $job15 = Start-Job -ScriptBlock $task15 -ArgumentList @("$SampleInterval","$MaxSamples")

                            #Wait for all the Jobs to finish
                            $null = Wait-Job -Job $job1,$job2,$job3,$job4,$job5,$job6,$job7,$job8,$job9,$job10,$job11,$job13,$job14,$job15

                            #Receive the results from each Job and save it to variables that will be queried in the next phase
                            $IP4Datagrams = Receive-Job -Job $job1
                            $NetworkBytesTotal = Receive-Job -Job $job2
                            $NetworkPacketReceivedErrors = Receive-Job -Job $job3
                            $NetworkPacketOutboundErrors = Receive-Job -Job $job4
                            $NetworkOutputQueue = Receive-Job -Job $job5
                            $MemCommitedBytes = Receive-Job -Job $job6
                            $MemAvailable = Receive-Job -Job $job7
                            $MemPagesPerSecond = Receive-Job -Job $job8
                            $PagingFileUsage = Receive-Job -Job $job9
                            $LogicalDiskTime = Receive-Job -Job $job10
                            $PhysicalDiskIdleTime = Receive-Job -Job $job11
                            $PhysicalDiskAvgDiskRead = Receive-Job -Job $job12
                            $PhysicalDiskAvgDiskWrite = Receive-Job -Job $job13
                            $AvgDiskReadQueueLenght = Receive-Job -Job $job14
                            $LogicalProcessorRunTime = Receive-Job -Job $job15

                            #When done, discard the jobs and free the memory
                            Remove-Job -Job $job1,$job2,$job3,$job4,$job5,$job6,$job7,$job8,$job9,$job10,$job11,$job13,$job14,$job15
                            

                    }#End of try
                      
                        catch
                        {
                                Write-Warning "There was an error while querying the Performance Counters on computer $computer. It is possible that the remote machine
                                has been disconnected from the network or turned off during the data gathering phase. Data collection on $computer will be skipped"
                                
                                $StatusOK = $false
                                
                                if($LogErrors)
                                {
                                Write-Warning "A Log File has been created in the following directory: '$ErrorLog'"
                                Get-Date | Out-File $ErrorLog -Force
                                $element | Out-File $ErrorLog -Append
                                $ErrorMessage | Out-File $ErrorLog -Append
                                }
                         
                        } #End catch    
                            

                        #Variable containing the end time of the sampling process
                        $SamplingEnd = Get-Date

                        #Variable storing the total number of seconds occurred to complete the process
                        $SamplingTotalSeconds = ($SamplingEnd - $SamplingStart).TotalSeconds

                        #Generate the Regular Expression that will match only numerical contents inside the Performace Counters Objects.
                        #The expression below means "match every character and/or digits before the column character (:)
                        $RegExp = [regex]'\A[^:]*:'
        
                        $props = [ordered]@{'ComputerName'= $objOperatingSystem.PSComputerName;
                            'OS Version'= $objOperatingSystem.Version;
                            'OS Name'= $objOperatingSystem.Caption;
                            'OS Architecture'= $objOperatingSystem.OSArchitecture;
                            'Serial Number'= $objOperatingSystem.SerialNumber;
                            'Organization'= $objOperatingSystem.Organization;
                            'Machine Domain' = $objComputerSystem.Domain;
                            'Active Directory Site' = (Get-ComputerSite($computer))
                            'DNS Search Order' = $objNetworkAdapterConfig.DnsServerSearchOrder -replace "\0x00","";
                            'Machine Manufacturer' = $objComputerSystem.Manufacturer;
                            'Machine Model' = $objComputerSystem.Model;
                            'Total Physical Memory (GB)' = $objComputerSystem.TotalPhysicalMemory / 1GB -as [int];
                            'Processor Sockets' = $objComputerSystem.NumberOfProcessors;
                            'Logical Processors Cores' = $objComputerSystem.NumberOfLogicalProcessors;
                            'IPv4Datagrams (packets/s) Samples'= $IP4Datagrams.Length;
                            'IPv4Datagrams (packets/s)'= foreach($ip4datagram in $IP4Datagrams){"{0:N2}" -f $ip4datagram.CookedValue};
                            'Network Packet Received Errors Samples' = $NetworkPacketReceivedErrors.Length;
                            'Network Packet Received Errors' = foreach($networkpacketreceivederrors in $NetworkPacketReceivedErrors){"{0:N2}" -f $networkpacketreceivederrors.CookedValue};
                            'Network Packet Outbound Errors Samples' = $NetworkPacketOutboundErrors.Length;
                            'Network Packet Outbound Errors' = foreach($networkpacketoutbounderrors in $NetworkPacketOutboundErrors){"{0:N2}" -f $networkpacketoutbounderrors.CookedValue};
                            'Network Interfaces (Bytes/sec) Samples' = $NetworkBytesTotal.Length;
                            'Network Interfaces (Bytes/sec)' = foreach($networkinterfacebytestotal in $NetworkBytesTotal){"{0:N2}" -f $networkinterfacebytestotal.CookedValue};
                            'Network Output Queue Length Samples' = $NetworkBytesTotal.Length;
                            'Network Output Queue Length' = foreach($networkoutputqueue in $NetworkOutputQueue){"{0:N2}" -f$networkoutputqueue.CookedValue};
                            'Available Memory (GB) Samples' = $MemAvailable.Length;
                            'Available Memory (GB)' = foreach($memavailable in $MemAvailable){$memavailable.CookedValue / 1GB -as [int]};
                            'Memory Pages per Second Samples' = $MemPagesPerSecond.Length;
                            'Memory Pages per Second' = foreach($mempagespersecond in $MemPagesPerSecond){"{0:N1}" -f $mempagespersecond.CookedValue};
                            'Memory Paging (%) Samples' =  $PagingFileUsage.Length;
                            'Memory Paging (%)' = foreach($pagingfileusage in $PagingFileUsage){"{0:N1}" -f$pagingfileusage.CookedValue};
                            'CommittedBytes (%) Samples' = $MemCommitedBytes.Length;
                            'CommittedBytes (%)'=foreach($memcommittedbytes in $MemCommitedBytes){"{0:N1}" -f $memcommitedbytes.CookedValue};
                            'Logical Disk Time (%) Samples' = $LogicalDiskTime.Length;
                            'Logical Disk Time (%)' = foreach($logicaldisktime in $LogicalDiskTime){"{0:N1}" -f $logicaldisktime.CookedValue};
                            'Average Disk Read Queue Samples' = $AvgDiskReadQueueLenght.Length;
                            'Average Disk Read Queue' = foreach($avgdiskreadqueuelenght in $AvgDiskReadQueueLenght){"{0:N2}" -f $avgdiskreadqueuelenght.CookedValue};
                            'Physical Disk Idle Time (ms) Samples' = $PhysicalDiskIdleTime.Length;
                            'Physical Disk Idle Time (ms)' = foreach($physicaldiskidletime in $PhysicalDiskIdleTime){"{0:N2}" -f $physicaldiskidletime.CookedValue};
                            'Physical Disk Average Read (ms) Samples' = $PhysicalDiskAvgDiskRead.Length;
                            'Physical Disk Average Read (ms)' = foreach($physicaldiskavgdiskread in $PhysicalDiskAvgDiskRead){"{0:N2}" -f $physicaldiskavgdiskread.CookedValue};
                            'Physical Disk Average Write (ms) Samples' =  $PhysicalDiskAvgDiskWrite.Length;
                            'Physical Disk Average Write (ms)' = foreach($physicaldiskavgdiskwrite in $PhysicalDiskAvgDiskWrite){"{0:N2}" -f $physicaldiskavgdiskwrite.CookedValue};
                            'Logical Processor Total Activity (%) Samples' = $LogicalProcessorRunTime.Length;
                            'Logical Processor Total Activity (%)' = foreach($logicalprocessorruntime in $LogicalProcessorRunTime){"{0:N2}" -f $logicalprocessorruntime.CookedValue};
                            'Data Sampling Date' = ($SamplingEnd);
                            'Total Sampling Interval in seconds'= "{0:N1}" -f $SamplingTotalSeconds}

                            Write-Verbose "All the queries to the required counters of $computer have been completed. Data sampling finished in $SamplingTotalSeconds seconds"

                            $obj = New-Object -TypeName PSObject -Property $props
                            
                            Write-Output $obj

                        }#End of if($StatusOK = $true)

                    #Update the Progress Bar values at every cycle
                    $CompletionPercentage += $SingleComputerPercentage
                            
                    if($ShowProgressBar){Write-Progress -Activity "Analyzing computer $computer" -PercentComplete $CompletionPercentage}
                            
                                    
                    }# End of main foreach ($computer in $computername) loop
                 
            }#End of Process
       #END
       End
       {
          if($ShowProgressBar){Write-Progress -Activity "Operation Completed" -Completed}

          Set-Culture $oldCulture
       } 
 }#EOF

  


 ################################################################
 ################################################################



 
 <#
.Synopsis
   This function will query any MS-SQL Server Database to get information stored in the DB tables. 
   It accepts as arguments a connection string (necessary to open a connection to the Server), and a specific query (a SELECT statement) written in Transact-SQL language
.EXAMPLE
   .\Get-DataFromSQLServer -ConnectionString "Server = <servername\instance>; Database = <databasename>; Trusted_Connection = True" -QueryStatement "SELECT * FROM <table> WHERE <conditions>"

.EXAMPLE
   
   The Get-DataFromSQLServer cmdlet can also be used to pass the result of its Database query to the Start-SystemScannerMT cmdlet as an array of [string] and print the output on the screen:

   .\Get-DataFromSQLServer -ConnectionString $connectionstring -QueryStatement $queryStatement | Start-SystemScannerMT | Format-Table

#>
 function Get-DataFromSQLServer {
    [CmdletBinding()]
    Param (
        [string]$ConnectionString = $SQLConnectionStringDefault,
        
        #The $queryStatemet variable is an ordinary Transact SQL (SELECT) query  
        [string]$QueryStatement = $SqueryStatementDefault,
        [switch]$LogErrors
        
    )
    Write-Verbose "Beginning connection to the SQL Server Database"
    
    try{
            #Create a DotNet SQLConnection Object to be used as an interface between the script and the Database server
            $connection = New-Object -TypeName System.Data.SqlClient.SqlConnection
    
    
            #Pass the connection string to the SQLConnection Object...
            $connection.ConnectionString = $ConnectionString
    
            #...and then, after the connection to the DB has been established, call a SQL query previously created and stored in the $queryStatement variable
            $SQLcommand = $connection.CreateCommand()
            $SQLcommand.CommandText = $QueryStatement

            Write-Verbose "The SQL Server has accepted the connection based on the following parameters:"
            Write-Verbose "CONNECTION STRING = $ConnectionString"
            Write-Verbose "QUERY STATEMENT = $QueryStatement" 
    
            #Transaction Management sequence
            $adapter = New-Object -TypeName System.Data.SqlClient.SqlDataAdapter $SQLcommand
            $dataset = New-Object -TypeName System.Data.DataSet
            $adapter.Fill($dataset) | Out-Null
            
            Write-Verbose "Data Set retrieved. Total number of elements in the Data Set is $($dataset.Tables[0].GetList().Count)"  
            $dataset.Tables[0]

            #Close the connection to the DB when finished
            $connection.close()
            
    }
    catch
    {
            Write-Warning "There was an error during the connection attempt with SQL Server.`
Please verify that you are trying to connect using a valid Connection String and a valid Query Statement of type SELECT."
            if($LogErrors)
            {
            Write-Warning "A Log File has been created in the following directory: '$ErrorLog'"
            Get-Date | Out-File $ErrorLog -Force
            $element | Out-File $ErrorLog -Append
            $ErrorMessage | Out-File $ErrorLog -Append
            }
    }
}



#########################################################
#########################################################

 <#
.Synopsis
   This function will update the records of any table on a MS-SQL Server Database as a transaction. 
   It accepts as arguments a connection string (necessary to open a connection to the Server), and a specific query (UPDATE or SELECT statement) written in Transact-SQL language
.EXAMPLE
   .\Set-DataToSQLServer -ConnectionString "Server = <servername\instance>; Database = <databasename>; Trusted_Connection = True" -QueryStatement "UPDATE <table> SET <conditions>"

.EXAMPLE
   
   The Set-DataToSQLServer cmdlet will only accept arguments for the Database query from the pipeline. Use the Start-SystemScannerMT cmdlet to pass a 
   [PSObject] to Set-DataToSQLServer:

   .\Set-DataToSQLServer -ConnectionString $connectionstring -QueryStatement $queryStatement | Start-SystemScannerMT | Format-Table

#>
function Set-DataToSQLServer{
    
    param(
    [Parameter(Mandatory=$true, ValueFromPipeLine=$true)]
    [Object[]]$ObjScanner,
    [string]$ConnectionString = $SQLConnectionStringDefault,
    [switch]$LogErrors
       
    )

    Process
    {


        try
        {
            #Is it possible to modify here the default UPDATE (or INSERT) statement that will be used to set new date into the SQL Server DB with the Set-DataToSQLServer cmdlet.
            #Please consider a further optimization of the normalization rules in the example query below for all the [String] values to upload on the DB
            foreach($objscanner in $ObjScanner)
            {
            Write-Verbose "Processing: $objScanner"
            $UQueryStatement = @"
            UPDATE [SystemInfoTEST].[dbo].[SysInfo2] SET 
            [OSVersion] ='$($objScanner.'OS Version')',
            [AvailableMemory(GB)] ='$($objScanner.'Available Memory (GB)')',
            [AverageDiskReadQueue] ='$($objScanner.'Average Disk Read Queue')',
            [CommittedBytes(%)] ='$($objScanner.'CommittedBytes (%)')',
            [DNSSearchOrder] ='$($objScanner.'DNS Search Order')',
            [LogicalDiskTime(%)] ='$($objScanner.'Logical Disk Time (%)')',
            [LogicalProcessorTotalActivity(%)] ='$($objScanner.'Logical Processor Total Activity (%)')',
            [LogicalProcessorsCores] ='$($objScanner.'Logical Processors Cores')',
            [MachineDomain] ='$($objScanner.'Machine Domain')',
            [ActiveDirectorySite] = '$($objScanner.'Active Directory Site')',
            [MachineManufacturer] ='$($objScanner.'Machine Manufacturer')',
            [MachineModel] ='$($objScanner.'Machine Model')',
            [MemoryPagesPerSecond] ='$($objScanner.'Memory Pages per Second')',
            [MemoryPaging(%)] = '$($objScanner.'Memory Paging (%)')',
            [NetworkInterfaces(Bytes/sec)] ='$($objScanner.'Network Interfaces (Bytes/sec)')',
            [NetworkPacketsReceiveErrors] = '$($objScanner.'Network Packet Received Errors')',
            [NetworkPacketsOutboundErrors] = '$($objScanner.'Network Packet Outbound Errors')',
            [NetworkOutputQueueLength] ='$($objScanner.'Network Output Queue Length')',
            [Organization] ='$($objScanner.'Organization')',
            [OSArchitecture] ='$($objScanner.'OS Architecture')',
            [OSName] ='$($objScanner.'OS Name')',
            [PhysicalDiskAverageRead(ms)] ='$($objScanner.'Physical Disk Average Read (ms)')',
            [PhysicalDiskAverageWrite(ms)] ='$($objScanner.'Physical Disk Average Write (ms)')',
            [PhysicalDiskIdleTime(ms)] ='$($objScanner.'Physical Disk Idle Time (ms)')',
            [ProcessorSockets] ='$($objScanner.'Processor Sockets')',
            [SerialNumber] ='$($objScanner.'Serial Number')',
            [TotalPhysicalMemory(GB)] ='$($objScanner.'Total Physical Memory (GB)')',
            [DataSamplingDate] = '$($objScanner.'Data Sampling Date')',
            [TotalSamplingIntervalInSeconds] ='$($objScanner.'Total Sampling Interval in seconds')'
            
             WHERE ComputerName = '$($objScanner.ComputerName)'
"@
        }
        Write-Verbose "Invoking the following INSERT/UPDATE Query statement on the SQL Server:"
        Write-Verbose " $UQueryStatement"
        Invoke-DatabaseQuery -ConnectionString $ConnectionString -QueryStatement $UQueryStatement
        }
        catch
        {
            Write-Warning "There was an error during the connection attempt with SQL Server.`
Please verify that you are trying to connect using a valid Connection String and a valid Query Statement of type UPDATE/INSERT."
            if($LogErrors)
            {
            Write-Warning "A Log File has been created in the following directory: '$ErrorLog'"
            Get-Date | Out-File $ErrorLog -Force
            $element | Out-File $ErrorLog -Append
            $ErrorMessage | Out-File $ErrorLog -Append
            }
            
        }
    }
}


#########################################################
#                                                       #
#                    HELPER FUNCTIONS                   #
#                                                       #
#########################################################


#The Get-ComputerSite is a wrapper function calling the "nltest /dsgetsite" command during the initial connection of the script to the 
#Active Directory LDAP repository. This function returns the Computer Site (in form of [string]) of the computer ($ComputerName) passed as argument 
function Get-ComputerSite($ComputerName)
{
   $site = nltest /server:$ComputerName /dsgetsite 2>$null
   if($LASTEXITCODE -eq 0){ $site[0] }

}


#The Invoke-DatabaseQuery is a service function used by the Set-DataToSQLServer cmdlet to write on the SQL Server DB all the information retrieved by
#the PSObject generated by the Start-SystemScanner cmdlet
function Invoke-DatabaseQuery {
    [CmdletBinding(SupportsShouldProcess=$True,
                   ConfirmImpact='Low')]
    param (
        [string]$ConnectionString,
        [string]$QueryStatement
        
    )
    
    $connection = New-Object -TypeName System.Data.SqlClient.SqlConnection
    
    
    $connection.ConnectionString = $ConnectionString
    $command = $connection.CreateCommand()
    $command.CommandText = $QueryStatement
    if ($pscmdlet.shouldprocess($QueryStatement)) {
        $connection.Open()
        $command.ExecuteNonQuery() | Out-Null
        
        #Close the connection to the DB when finished
        $connection.close()
    }
}


#########################################################
#                                                       #
#                MULTITHREAD ENGINE                     #
#  Author: Ryan Witschger - http://www.Get-Blog.com     #
#                                                       #
#########################################################



#.Synopsis
#    This is a quick and open-ended script multi-threader searcher
#    
#.Description
#    This script will allow any general, external script to be multithreaded by providing a single
#    argument to that script and opening it in a seperate thread.  It works as a filter in the 
#    pipeline, or as a standalone script.  It will read the argument either from the pipeline
#    or from a filename provided.  It will send the results of the child script down the pipeline,
#    so it is best to use a script that returns some sort of object.
#
#    Authored by Ryan Witschger - http://www.Get-Blog.com
#    
#.PARAMETER Command
#    This is where you provide the PowerShell Cmdlet / Script file that you want to multithread.  
#    You can also choose a built in cmdlet.  Keep in mind that your script.  This script is read into 
#    a scriptblock, so any unforeseen errors are likely caused by the conversion to a script block.
#    
#.PARAMETER ObjectList
#    The objectlist represents the arguments that are provided to the child script.  This is an open ended
#    argument and can take a single object from the pipeline, an array, a collection, or a file name.  The 
#    multithreading script does it's best to find out which you have provided and handle it as such.  
#    If you would like to provide a file, then the file is read with one object on each line and will 
#    be provided as is to the script you are running as a string.  If this is not desired, then use an array.
#    
#.PARAMETER InputParam
#    This allows you to specify the parameter for which your input objects are to be evaluated.  As an example, 
#    if you were to provide a computer name to the Get-Process cmdlet as just an argument, it would attempt to 
#    find all processes where the name was the provided computername and fail.  You need to specify that the 
#    parameter that you are providing is the "ComputerName".
#
#.PARAMETER AddParam
#    This allows you to specify additional parameters to the running command.  For instance, if you are trying
#    to find the status of the "BITS" service on all servers in your list, you will need to specify the "Name"
#    parameter.  This command takes a hash pair formatted as follows:  
#
#    @{"ParameterName" = "Value"}
#    @{"ParameterName" = "Value" ; "ParameterTwo" = "Value2"}
#
#.PARAMETER AddSwitch
#    This allows you to add additional switches to the command you are running.  For instance, you may want 
#    to include "RequiredServices" to the "Get-Service" cmdlet.  This parameter will take a single string, or 
#    an aray of strings as follows:
#
#    "RequiredServices"
#    @("RequiredServices", "DependentServices")
#
#.PARAMETER MaxThreads
#    This is the maximum number of threads to run at any given time.  If resources are too congested try lowering
#    this number.  The default value is 20.
#    
#.PARAMETER SleepTimer
#    This is the time between cycles of the child process detection cycle.  The default value is 200ms.  If CPU 
#    utilization is high then you can consider increasing this delay.  If the child script takes a long time to
#    run, then you might increase this value to around 1000 (or 1 second in the detection cycle).
#
#    
#.EXAMPLE
#    Both of these will execute the script named ServerInfo.ps1 and provide each of the server names in AllServers.txt
#    while providing the results to the screen.  The results will be the output of the child script.
#    
#    gc AllServers.txt | Start-MultiThreadEngine -Command .\ServerInfo.ps1
#    .\Run-CommandMultiThreaded.ps1 -Command .\ServerInfo.ps1 -ObjectList (gc .\AllServers.txt)
#
#    SCENARIO SPECIFIC EXAMPLES BELOW: added by Daniele Mancuso 18/10/2014
#
#    Start-MultiThreadEngine -Command "Start-SystemScanner" -Verbose -ObjectList (gc .\Computers.csv) | Set-DataToSQLServer -Verbose
#
#    Start-MultiThreadEngine -Command "Start-SystemScanner" -Verbose -ObjectList (gc .\Computers.txt) | Set-DataToSQLServer -Verbose
#
#    Start-MultiThreadEngine -Command "Start-SystemScanner" -Verbose -ObjectList ($(Get-DataFromSQLServer).computername) | Set-DataToSQLServer -Verbose
#
#    Start-MultiThreadEngine -Command "Start-SystemScanner" -Verbose @{"SampleInterval" = "5"; "MaxSamples"="5"} -AddSwitch @("Verbose", "LogErrors") -ObjectList (Get-Content "C:\Users\SomeLocation\comp.txt")`
#    | Convert-OutputForCSV -OutputPropertyType Stack -Verbose  | Export-Csv -NoTypeInformation C:\cccc.csv
#
#    Start-MultiThreadEngine -Command "Start-SystemScannerMT" -AddSwitch @("Verbose", "LogErrors", "UseLocalCulture") -AddParam @{"SampleInterval" = "5"; "MaxSamples"="10"}  -Verbose -ObjectList (gc "C:\Users\daniele.mancuso\Desktop\mymachine.txt") | Select  'Active Directory Site','ComputerName','OS Version','OS Name','OS Architecture','Serial Number','Organization','Machine Domain','DNS Search Order','Machine Manufacturer','Machine Model','Total Physical Memory (GB)','Processor Sockets', 'Logical Processors Cores', 'IPv4Datagrams (packets/s)','Network Packet Received Errors','Network Packet Outbound Errors','Network Interfaces (Bytes/sec)','Network Output Queue Length','Available Memory (GB)','Memory Pages per Second','Memory Paging (%)','CommittedBytes (%)','Logical Disk Time (%)','Average Disk Read Queue','Physical Disk Idle Time (ms)','Physical Disk Average Read (ms)','Physical Disk Average Write (ms)','Logical Processor Total Activity (%)','Network Packet Received Errors Samples','Network Packet Outbound Errors Samples','Network Interfaces (Bytes/sec) Samples','Network Output Queue Length Samples','Available Memory (GB) Samples','Memory Pages per Second Samples','Memory Paging (%) Samples','CommittedBytes (%) Samples','Logical Disk Time (%) Samples','Average Disk Read Queue Samples','Physical Disk Idle Time (ms) Samples','Physical Disk Average Read (ms) Samples','Physical Disk Average Write (ms) Samples','Logical Processor Total Activity (%) Samples','Data Sampling Date','Total Sampling Interval in seconds'| Convert-OutputForCSV -Verbose -OutputPropertyType Comma | Export-Csv -NoTypeInformation C:\somelocation\file.csv
#    
#.EXAMPLE
#    The following demonstrates the use of the AddParam statement
#    
#    $ObjectList | Start-MultiThreadEngine -Command "Get-Service" -InputParam ComputerName -AddParam @{"Name" = "BITS"}
#    
#.EXAMPLE
#    The following demonstrates the use of the AddSwitch statement
#    
#    $ObjectList | Start-MultiThreadEngine -Command "Get-Service" -AddSwitch @("RequiredServices", "DependentServices")
#
#.EXAMPLE
#    The following demonstrates the use of the script in the pipeline
#    
#    $ObjectList | Start-MultiThreadEngine -Command "Get-Service" -InputParam ComputerName -AddParam @{"Name" = "BITS"} | Select Status, MachineName
#

function Start-MultiThreadEngine{

Param($Command = $(Read-Host "Enter the script file"), 
    [Parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]$ObjectList,
    $InputParam = $Null,
    $MaxThreads = 40,
    $SleepTimer = 200,
    $MaxResultTime = 12000,
    [HashTable]$AddParam = @{},
    [Array]$AddSwitch = @()
)

Begin{
        $ISS = [system.management.automation.runspaces.initialsessionstate]::CreateDefault()
        $RunspacePool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $ISS, $Host)
        $RunspacePool.Open()
        
        If ($(Get-Command | Select-Object Name) -match $Command){
            $Code = $Null
        }Else{
            $OFS = "`r`n"
            $Code = [ScriptBlock]::Create($(Get-Content $Command))
            Remove-Variable OFS
        }
        $Jobs = @()
}

Process{
        Write-Progress -Activity "Preloading threads" -Status "Starting Job $($jobs.count)"
        ForEach ($Object in $ObjectList){
            If ($Code -eq $Null){
                $PowershellThread = [powershell]::Create().AddCommand($Command)
            }Else{
                $PowershellThread = [powershell]::Create().AddScript($Code)
            }
            If ($InputParam -ne $Null){
                $PowershellThread.AddParameter($InputParam, $Object.ToString()) | out-null
            }Else{
                $PowershellThread.AddArgument($Object.ToString()) | out-null
            }
            ForEach($Key in $AddParam.Keys){
                $PowershellThread.AddParameter($Key, $AddParam.$key) | out-null
            }
            ForEach($Switch in $AddSwitch){
                $Switch
                $PowershellThread.AddParameter($Switch) | out-null
            }
            $PowershellThread.RunspacePool = $RunspacePool
            $Handle = $PowershellThread.BeginInvoke()
            $Job = "" | Select-Object Handle, Thread, object
            $Job.Handle = $Handle
            $Job.Thread = $PowershellThread
            $Job.Object = $Object.ToString()
            $Jobs += $Job
    }
        
}

    End{
        $ResultTimer = Get-Date
        While (@($Jobs | Where-Object {$_.Handle -ne $Null}).count -gt 0)  {
    
            $Remaining = "$($($Jobs | Where-Object {$_.Handle.IsCompleted -eq $False}).object)"
            If ($Remaining.Length -gt 60){
                $Remaining = $Remaining.Substring(0,60) + "..."
            }
            Write-Progress `
                -Activity "Waiting for Jobs - $($MaxThreads - $($RunspacePool.GetAvailableRunspaces())) of $MaxThreads threads running" `
                -PercentComplete (($Jobs.count - $($($Jobs | Where-Object {$_.Handle.IsCompleted -eq $False}).count)) / $Jobs.Count * 100) `
                -Status "$(@($($Jobs | Where-Object {$_.Handle.IsCompleted -eq $False})).count) remaining - $remaining" 

            ForEach ($Job in $($Jobs | Where-Object {$_.Handle.IsCompleted -eq $True})){
                $Job.Thread.EndInvoke($Job.Handle)
                $Job.Thread.Dispose()
                $Job.Thread = $Null
                $Job.Handle = $Null
                $ResultTimer = Get-Date
            }
            If (($(Get-Date) - $ResultTimer).totalseconds -gt $MaxResultTime){
                Write-Error "Child script appears to be frozen, try increasing MaxResultTime"
                Exit
            }
            Start-Sleep -Milliseconds $SleepTimer
        
        } 
        $RunspacePool.Close() | Out-Null
        $RunspacePool.Dispose() | Out-Null
    } 
}


Function Convert-OutputForCSV {
    <#
        .SYNOPSIS
            Provides a way to expand collections in an object property prior
            to being sent to Export-Csv.

        .DESCRIPTION
            Provides a way to expand collections in an object property prior
            to being sent to Export-Csv. This helps to avoid the object type
            from being shown such as system.object[] in a spreadsheet.

        .PARAMETER InputObject
            The object that will be sent to Export-Csv

        .PARAMETER OutPropertyType
            This determines whether the property that has the collection will be
            shown in the CSV as a comma delimmited string or as a stacked string.

            Possible values:
            Stack
            Comma

            Default value is: Stack

        .NOTES
            Name: Convert-OutputForCSV
            Author: Boe Prox
            Created: 24 Jan 2014
            Version History:
                1.1 - 02 Feb 2014
                    -Removed OutputOrder parameter as it is no longer needed; inputobject order is now respected 
                    in the output object
                1.0 - 24 Jan 2014
                    -Initial Creation

        .EXAMPLE
            $Output = 'PSComputername','IPAddress','DNSServerSearchOrder'

            Get-WMIObject -Class Win32_NetworkAdapterConfiguration -Filter "IPEnabled='True'" |
            Select-Object $Output | Convert-OutputForCSV | 
            Export-Csv -NoTypeInformation -Path NIC.csv    

            
            SCENARIO SPECIFIC EXAMPLE Added by Daniele Mancuso - 25/08/2014

            Start-SystemScanner "Localhost" | Select-Object * | Convert-OutputForCSV -OutputPropertyType Comma -Verbose  | Export-Csv -NoTypeInformation C:\Users\daniele.mancuso\Desktop\cccc.csv
            
            Description
            -----------
            Using a predefined set of properties to display ($Output), data is collected from the 
            Win32_NetworkAdapterConfiguration class and then passed to the Convert-OutputForCSV
            funtion which expands any property with a collection so it can be read properly prior
            to being sent to Export-Csv. Properties that had a collection will be viewed as a stack
            in the spreadsheet.        
            
    #>
    #Requires -Version 3.0
    [cmdletbinding()]
    Param (
        [parameter(ValueFromPipeline)]
        [psobject]$InputObject,
        [parameter()]
        [ValidateSet('Stack','Comma')]
        [string]$OutputPropertyType = 'Stack'
    )
    Begin {
        $PSBoundParameters.GetEnumerator() | ForEach {
            Write-Verbose "$($_)"
        }
        $FirstRun = $True
    }
    Process {
        If ($FirstRun) {
            $OutputOrder = $InputObject.psobject.properties.name
            Write-Verbose "Output Order:`n $($OutputOrder -join ', ' )"
            $FirstRun = $False
            #Get properties to process
            $Properties = Get-Member -InputObject $InputObject -MemberType *Property
            #Get properties that hold a collection
            $Properties_Collection = @(($Properties | Where-Object {
                $_.Definition -match "Collection|\[\]"
            }).Name)
            #Get properties that do not hold a collection
            $Properties_NoCollection = @(($Properties | Where-Object {
                $_.Definition -notmatch "Collection|\[\]"
            }).Name)
            Write-Verbose "Properties Found that have collections:`n $(($Properties_Collection) -join ', ')"
            Write-Verbose "Properties Found that have no collections:`n $(($Properties_NoCollection) -join ', ')"
        }
 
        $InputObject | ForEach {
            $Line = $_
            $stringBuilder = New-Object Text.StringBuilder
            $Null = $stringBuilder.AppendLine("[pscustomobject] @{")

            $OutputOrder | ForEach {
                If ($OutputPropertyType -eq 'Stack') {
                    $Null = $stringBuilder.AppendLine("`"$($_)`" = `"$(($line.$($_) | Out-String).Trim())`"")
                } ElseIf ($OutputPropertyType -eq "Comma") {
                    $Null = $stringBuilder.AppendLine("`"$($_)`" = `"$($line.$($_) -join ', ')`"")                   
                }
            }
            $Null = $stringBuilder.AppendLine("}")
 
            Invoke-Expression $stringBuilder.ToString()
        }
    }
    End {}
}

<#
OCTOSCANNER Module Configuration - Visibility Settings for cmdlets and variables
#>

Export-ModuleMember -Function Start-SystemScannerMT, Get-DataFromSQLServer, Set-DataToSQLServer, Start-MultiThreadEngine, Convert-OutputForCSV -Variable InputObject, OutputPropertyType
